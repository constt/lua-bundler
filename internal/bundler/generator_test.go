package bundler

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateBundle(t *testing.T) {
	b, err := NewBundler("test.lua", false, false)
	require.NoError(t, err, "NewBundler should not fail")

	// Add some test modules
	b.modules["./helper.lua"] = `local helper = {}
function helper.greet()
    return "Hello"
end
return helper`

	b.modules["https://example.com/remote.lua"] = `local remote = {}
function remote.fetch()
    return "data"
end
return remote`

	mainContent := `local helper = require('./helper.lua')
local remote = loadstring(game:HttpGet('https://example.com/remote.lua'))()

print(helper.greet())
print(remote.fetch())`

	result := b.generateBundle(mainContent)

	tests := []struct {
		name    string
		check   func(string) bool
		message string
	}{
		{
			name: "contains bundle header",
			check: func(s string) bool {
				return strings.Contains(s, "-- Bundled Lua Script") &&
					strings.Contains(s, "-- Generated by Lua Bundler")
			},
			message: "should contain bundle header",
		},
		{
			name: "contains EmbeddedModules table",
			check: func(s string) bool {
				return strings.Contains(s, "local EmbeddedModules = {}")
			},
			message: "should contain EmbeddedModules table",
		},
		{
			name: "contains loadModule function",
			check: func(s string) bool {
				return strings.Contains(s, "local function loadModule(url)")
			},
			message: "should contain loadModule function",
		},
		{
			name: "contains helper module",
			check: func(s string) bool {
				return strings.Contains(s, `EmbeddedModules["./helper.lua"]`) &&
					strings.Contains(s, "function helper.greet()")
			},
			message: "should contain helper module",
		},
		{
			name: "contains remote module",
			check: func(s string) bool {
				return strings.Contains(s, `EmbeddedModules["https://example.com/remote.lua"]`) &&
					strings.Contains(s, "function remote.fetch()")
			},
			message: "should contain remote module",
		},
		{
			name: "replaces require calls",
			check: func(s string) bool {
				return strings.Contains(s, `loadModule("./helper.lua")`) &&
					!strings.Contains(s, `require('./helper.lua')`)
			},
			message: "should replace require calls with loadModule",
		},
		{
			name: "replaces loadstring calls",
			check: func(s string) bool {
				return strings.Contains(s, `loadModule("https://example.com/remote.lua")`) &&
					!strings.Contains(s, `loadstring(game:HttpGet('https://example.com/remote.lua'))()`)
			},
			message: "should replace loadstring calls with loadModule",
		},
		{
			name: "contains main script section",
			check: func(s string) bool {
				return strings.Contains(s, "-- Main Script")
			},
			message: "should contain main script section",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.True(t, tt.check(result), "generateBundle() %s", tt.message)
		})
	}
}

func TestEscapeString(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "simple string",
			input:    "hello",
			expected: "hello",
		},
		{
			name:     "string with quotes",
			input:    `hello "world"`,
			expected: `hello \"world\"`,
		},
		{
			name:     "string with backslashes",
			input:    `path\to\file`,
			expected: `path\\to\\file`,
		},
		{
			name:     "string with both quotes and backslashes",
			input:    `"C:\Program Files\App"`,
			expected: `\"C:\\Program Files\\App\"`,
		},
		{
			name:     "empty string",
			input:    "",
			expected: "",
		},
		{
			name:     "URL with protocol",
			input:    "https://example.com/path?param=value",
			expected: "https://example.com/path?param=value",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := escapeString(tt.input)
			assert.Equal(t, tt.expected, result, "escapeString() result should match expected")
		})
	}
}

func TestGenerateBundle_EmptyModules(t *testing.T) {
	b, err := NewBundler("test.lua", false, false)
	require.NoError(t, err, "NewBundler should not fail")
	// No modules added

	mainContent := `print("Hello World")`

	result := b.generateBundle(mainContent)

	// Should still generate valid structure even with no modules
	assert.Contains(t, result, "local EmbeddedModules = {}", "generateBundle() should contain EmbeddedModules table even with no modules")
	assert.Contains(t, result, "local function loadModule(url)", "generateBundle() should contain loadModule function even with no modules")
	assert.Contains(t, result, "-- Main Script", "generateBundle() should contain main script section")
	assert.Contains(t, result, `print("Hello World")`, "generateBundle() should contain original main content")
}

func TestGenerateBundle_ModuleIndentation(t *testing.T) {
	b, err := NewBundler("test.lua", false, false)
	require.NoError(t, err, "NewBundler should not fail")

	moduleContent := `local test = {}

function test.method()
    if true then
        print("nested")
    end
end

return test`

	b.modules["test"] = moduleContent

	result := b.generateBundle("local t = require('test')")

	// Check that indentation is properly added (4 spaces for each line)
	lines := strings.Split(result, "\n")
	moduleStarted := false
	moduleEnded := false

	for _, line := range lines {
		if strings.Contains(line, `EmbeddedModules["test"] = function()`) {
			moduleStarted = true
			continue
		}

		if moduleStarted && !moduleEnded {
			if strings.TrimSpace(line) == "end" && !strings.HasPrefix(line, "    ") {
				moduleEnded = true
				continue
			}

			// Non-empty lines in module should be indented with 4 spaces
			if strings.TrimSpace(line) != "" {
				assert.True(t, strings.HasPrefix(line, "    "), "Module line should be indented with 4 spaces: %q", line)
			}
		}
	}
}

func TestGenerateBundle_NestedRequires(t *testing.T) {
	b, err := NewBundler("test.lua", false, false)
	require.NoError(t, err, "NewBundler should not fail")

	// Add a module that requires another module (nested require)
	b.modules["modules.config"] = `local config = {}
local locations = require("modules.locations")
local fishing_methods = require("modules.fishing_methods")

config.locations = locations
config.methods = fishing_methods

return config`

	b.modules["modules.locations"] = `local locations = {}
locations.spots = {"spot1", "spot2"}
return locations`

	b.modules["modules.fishing_methods"] = `local methods = {}
methods.types = {"rod", "net"}
return methods`

	mainContent := `local config = require("modules.config")
print(config.locations.spots[1])`

	result := b.generateBundle(mainContent)

	// Verify that nested requires in modules.config are replaced with loadModule
	assert.Contains(t, result, `loadModule("modules.locations")`, "should replace nested require in module with loadModule")
	assert.Contains(t, result, `loadModule("modules.fishing_methods")`, "should replace nested require in module with loadModule")
	assert.NotContains(t, result, `require("modules.locations")`, "should not contain original require call in module")
	assert.NotContains(t, result, `require("modules.fishing_methods")`, "should not contain original require call in module")
	
	// Verify the module content is properly embedded
	assert.Contains(t, result, `EmbeddedModules["modules.config"]`, "should contain config module")
	assert.Contains(t, result, `EmbeddedModules["modules.locations"]`, "should contain locations module")
	assert.Contains(t, result, `EmbeddedModules["modules.fishing_methods"]`, "should contain fishing_methods module")
}

func TestGenerateBundle_NestedRequiresInLocations(t *testing.T) {
	b, err := NewBundler("test.lua", false, false)
	require.NoError(t, err, "NewBundler should not fail")

	// Test the exact scenario from the user: modules.locations requiring modules.fishing_methods
	b.modules["modules.locations"] = `-- modules/locations.lua
-- Fishing location definitions

local fishing_methods = require("modules.fishing_methods")

local locations = {}
return locations`

	b.modules["modules.fishing_methods"] = `local methods = {}
methods.types = {"rod", "net"}
return methods`

	mainContent := `local locations = require("modules.locations")`

	result := b.generateBundle(mainContent)

	// Verify that nested require in modules.locations is replaced
	assert.Contains(t, result, `loadModule("modules.fishing_methods")`, "should replace nested require in modules.locations with loadModule")
	assert.NotContains(t, result, `require("modules.fishing_methods")`, "should not contain original require call in modules.locations")
	
	// Print the result for debugging
	t.Logf("Generated bundle:\n%s", result)
}

func TestGenerateBundle_ExactUserScenario(t *testing.T) {
	b, err := NewBundler("test.lua", false, false)
	require.NoError(t, err, "NewBundler should not fail")

	// Exact scenario from user: modules.config requiring modules.locations and modules.fishing_methods
	b.modules["modules.config"] = `local config = {}
local locations = require("modules.locations")
local fishing_methods = require("modules.fishing_methods")

return config`

	b.modules["modules.locations"] = `local locations = {}
return locations`

	b.modules["modules.fishing_methods"] = `local methods = {}
return methods`

	mainContent := `local config = require("modules.config")`

	result := b.generateBundle(mainContent)

	// Print full result for debugging
	t.Logf("Full generated bundle:\n%s", result)

	// Check that modules.config has loadModule calls, not require calls
	// Find the modules.config section
	lines := strings.Split(result, "\n")
	inConfigModule := false
	configModuleLines := []string{}
	
	for _, line := range lines {
		if strings.Contains(line, `EmbeddedModules["modules.config"]`) {
			inConfigModule = true
		}
		if inConfigModule {
			configModuleLines = append(configModuleLines, line)
			if strings.TrimSpace(line) == "end" && len(configModuleLines) > 1 {
				break
			}
		}
	}
	
	configModuleContent := strings.Join(configModuleLines, "\n")
	t.Logf("modules.config module content:\n%s", configModuleContent)

	// Verify nested requires are replaced
	assert.Contains(t, result, `loadModule("modules.locations")`, "should replace require in modules.config with loadModule")
	assert.Contains(t, result, `loadModule("modules.fishing_methods")`, "should replace require in modules.config with loadModule")
	assert.NotContains(t, configModuleContent, `require("modules.locations")`, "should not contain require in modules.config")
	assert.NotContains(t, configModuleContent, `require("modules.fishing_methods")`, "should not contain require in modules.config")
}
