package bundler

import (
	"fmt"
	"regexp"
	"strings"
)

// generateBundle creates the final bundled output
func (b *Bundler) generateBundle(mainContent string) string {
	var output strings.Builder

	output.WriteString("-- Bundled Lua Script\n")
	output.WriteString("-- Generated by Lua Bundler\n")

	// Generate EmbeddedModules table
	output.WriteString("local EmbeddedModules = {}\n\n")

	// Add all modules
	for path, content := range b.modules {
		output.WriteString(fmt.Sprintf("-- Module: %s\n", path))
		output.WriteString(fmt.Sprintf("EmbeddedModules[\"%s\"] = function()\n", escapeString(path)))

		// Process module content to replace nested requires with loadModule calls
		processedContent := b.replaceModuleCalls(content)

		// Indent content
		lines := strings.Split(processedContent, "\n")
		for _, line := range lines {
			if strings.TrimSpace(line) != "" {
				output.WriteString("    " + line + "\n")
			} else {
				output.WriteString("\n")
			}
		}

		output.WriteString("end\n\n")
	}

	// Add loadModule function
	output.WriteString("-- Load module helper function\n")
	output.WriteString("local function loadModule(url)\n")
	output.WriteString("    -- Try embedded module first\n")
	output.WriteString("    if EmbeddedModules[url] then\n")
	output.WriteString("        return EmbeddedModules[url]()\n")
	output.WriteString("    end\n")
	output.WriteString("    \n")
	output.WriteString("    -- Fallback to original require\n")
	output.WriteString("    return require(url)\n")
	output.WriteString("end\n\n")

	// Replace require() and loadstring() in main content
	processedMain := b.replaceModuleCalls(mainContent)

	output.WriteString("-- Main Script\n")
	output.WriteString(processedMain)

	return output.String()
}

// replaceModuleCalls replaces require() and loadstring() calls with loadModule() calls
func (b *Bundler) replaceModuleCalls(content string) string {
	// Support both quoted strings: require("path.to.file") and unquoted: require(path.to.file)
	requireRegex := regexp.MustCompile(`require\s*\(\s*(?:['"]([^'"]+)['"]|([a-zA-Z_][a-zA-Z0-9_.]*))\s*\)`)
	httpGetRegex := regexp.MustCompile(`loadstring\s*\(\s*game:HttpGet\s*\(\s*['"]([^'"]+)['"]\s*\)\s*\)\s*\(\s*\)`)
	// Pattern to detect HttpGet inside function calls (should NOT be replaced)
	funcCallHttpGetRegex := regexp.MustCompile(`\w+\s*\([^)]*loadstring\s*\(\s*game:HttpGet`)

	processedContent := content

	// Replace loadstring(game:HttpGet(...))() - but skip if inside function calls
	lines := strings.Split(processedContent, "\n")
	for i, line := range lines {
		// Skip lines with HttpGet inside function calls
		if funcCallHttpGetRegex.MatchString(line) {
			continue
		}
		// Replace HttpGet pattern in this line
		lines[i] = httpGetRegex.ReplaceAllStringFunc(line, func(match string) string {
			matches := httpGetRegex.FindStringSubmatch(match)
			if len(matches) > 1 {
				url := matches[1]
				return fmt.Sprintf("loadModule(\"%s\")", escapeString(url))
			}
			return match
		})
	}
	processedContent = strings.Join(lines, "\n")

	// Replace require() for bundled modules (check b.modules first, then isLocalModule)
	processedContent = requireRegex.ReplaceAllStringFunc(processedContent, func(match string) string {
		matches := requireRegex.FindStringSubmatch(match)
		if len(matches) > 1 {
			// matches[1] is quoted string, matches[2] is unquoted identifier
			modulePath := matches[1]
			if modulePath == "" && len(matches) > 2 {
				modulePath = matches[2]
			}
			if modulePath != "" {
				// If module is in b.modules (already bundled), replace with loadModule
				if _, exists := b.modules[modulePath]; exists {
					return fmt.Sprintf("loadModule(\"%s\")", escapeString(modulePath))
				}
				// Otherwise, check if it's a local module
				if b.isLocalModule(modulePath) {
					return fmt.Sprintf("loadModule(\"%s\")", escapeString(modulePath))
				}
			}
		}
		return match
	})

	return processedContent
}

// escapeString escapes special characters in strings for Lua
func escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}
